<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Lemonade Matrix: Ultimate Edition</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif; /* Fallback/Standard Font */
            background-color: #0d0d1e; /* Dark, matrix background */
            color: #00ff66; /* Neon green text */
        }
        #game-canvas {
            display: block;
            width: 100%;
            height: 400px;
            border: 4px solid #00ff66;
            box-shadow: 0 0 15px rgba(0, 255, 102, 0.5);
            margin: 0 auto;
        }
        .neon-glow {
            text-shadow: 0 0 5px #00ff66, 0 0 10px #00ff66;
        }
        .neon-stat {
            font-size: 1.25rem; 
            font-weight: bold;
        }
        .neon-button {
            background-color: #008844;
            color: #fff;
            box-shadow: 0 0 5px #00ff66;
            transition: all 0.2s;
        }
        .neon-button:hover:not(:disabled) {
            background-color: #00ff66;
            color: #0d0d1e;
            box-shadow: 0 0 20px #00ff66;
            transform: scale(1.02);
        }
        .neon-button:disabled {
            background-color: #333333; 
            color: #666;
            box-shadow: none;
            cursor: not-allowed;
        }
        .card-bg {
            background-color: #1a1a38; 
            border: 2px solid #00ff66;
        }

        /* --- ANIMATED STATUS STYLES --- */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 102, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 102, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 102, 0); }
        }

        .status-pulse {
            animation: pulse-green 2s infinite;
        }
        
        #stand-status-card {
            transition: all 0.5s ease;
        }
        #stand-status-text {
             text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }
        /* Ensure the entire body takes up minimal space for the iFrame */
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            min-height: 100vh;
        }
        #app-container {
            padding: 1rem;
        }
        
    </style>
</head>
<body class="flex items-start justify-center">

    <div id="app-container" class="w-full max-w-5xl space-y-4">

        <header class="text-center mb-4">
            <h1 class="text-3xl font-extrabold neon-glow">THE LEMONADE MATRIX: ULTIMATE</h1>
            <p class="text-sm text-gray-400">Management + Simulation = Escape</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">

            <!-- 1. Status & Stats (Left Column) -->
            <div class="lg:col-span-1 space-y-4">
                
                <!-- Animated Stand Status Card -->
                <div id="stand-status-card" class="p-4 rounded-xl shadow-lg bg-red-600 text-white transition-all duration-500 card-bg">
                    <h2 class="text-xl font-bold mb-3 neon-glow border-b border-gray-700 pb-2">OPERATIONAL STATUS</h2>
                    <div class="flex items-center justify-between">
                        <span id="stand-status-text" class="text-3xl font-extrabold text-white">SYSTEM OFFLINE</span>
                        <div id="stand-status-indicator" class="text-5xl">🛑</div>
                    </div>
                </div>

                <!-- Game Status Panel -->
                <div id="status-panel" class="p-4 rounded-xl shadow-lg card-bg">
                    <h2 class="text-xl font-bold mb-3 neon-glow border-b border-gray-700 pb-2">STATISTICS</h2>
                    <div class="space-y-3 text-sm">
                        <p>DAY: <span id="game-day" class="font-bold text-white neon-stat">1</span></p>
                        <p>MONEY: <span id="game-money" class="font-bold text-yellow-400 neon-stat">$50.00</span></p>
                        <p>CUPS LEFT: <span id="game-cups" class="font-bold text-blue-400 neon-stat">0</span></p>
                        <p>CONSCIOUSNESS (CP): <span id="game-cp" class="font-bold text-red-400 neon-stat">0</span></p>
                        <p id="game-event" class="text-xs italic text-orange-400 pt-2 border-t border-gray-700">No active events.</p>
                    </div>
                </div>

                <!-- Upgrades Panel -->
                <div id="upgrade-panel" class="p-4 rounded-xl shadow-lg card-bg">
                    <h2 class="text-xl font-bold mb-3 neon-glow border-b border-gray-700 pb-2">UPGRADES (CP REQUIRED)</h2>
                    <div id="upgrade-buttons" class="space-y-3">
                        <!-- Upgrade buttons injected here -->
                    </div>
                </div>
            </div>

            <!-- 2. 3D Canvas and Output (Center Column) -->
            <div class="lg:col-span-2">
                <canvas id="game-canvas"></canvas>
                
                <!-- Price Control -->
                <div class="mt-4 p-3 card-bg rounded-xl">
                    <h3 class="text-lg font-bold text-white mb-2">Price Per Cup: <span id="game-price" class="neon-stat">$0.50</span></h3>
                    <input type="range" min="0.50" max="2.50" step="0.50" value="0.50" id="price-slider" 
                           oninput="updatePriceDisplay(this.value)" 
                           onchange="gameState.pricePerCup = parseFloat(this.value); updateUI();"
                           class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <p class="text-xs text-gray-400 mt-1">Low price = High Volume/Low CP. High price = Low Volume/High CP.</p>
                </div>


                <!-- Game Output Area -->
                <div id="game-output" class="min-h-[120px] max-h-[250px] mt-4 p-3 bg-black border-2 border-gray-800 rounded-lg overflow-y-auto text-gray-300 text-sm">
                    <p class="neon-glow">System initialized. Awaiting user input...</p>
                </div>

                <!-- Game Action Buttons -->
                <div id="game-actions" class="mt-4 flex flex-wrap gap-2 justify-center">
                    <!-- Action buttons injected here -->
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- Game State ---
        let gameState = {
            day: 0,
            money: 50.00,
            cupsLeft: 0,
            pricePerCup: 0.50,
            cp: 0, 
            upgrades: {
                truthSerum: false, 
                holographicSign: false, 
                redPillReady: false, 
            },
            isSelling: false, 
            gameOver: false,
            transactionStartTime: null, 
            currentEvent: { type: 'NONE', modifier: 1, message: 'No active events.' }, 
            dailyFollowUsed: false, 
            
            // Goals
            escapeMoneyRequired: 200,
            escapeCPRequired: 500,
            
            // Management Constants
            COST_PER_10_CUPS: 15.00,
            CUPS_PER_BATCH: 10,
        };

        const TRANSACTION_DURATION_SECONDS = 3.0; 

        const UPGRADE_COSTS = {
            truthSerum: 100,
            holographicSign: 250,
            redPillReady: 500,
        };

        const Scenes = {
            START: 'START',
            PREPARATION: 'PREPARATION', 
            SELL: 'SELL',
            END_DAY: 'END_DAY',
            VICTORY: 'VICTORY',
            FAILURE: 'FAILURE',
        };
        let currentScene = Scenes.START;


        // --- UI Element References ---
        const canvas = document.getElementById('game-canvas');
        const gameOutput = document.getElementById('game-output');
        const gameActions = document.getElementById('game-actions');
        const upgradeButtonsDiv = document.getElementById('upgrade-buttons');
        const statusCard = document.getElementById('stand-status-card');
        const statusText = document.getElementById('stand-status-text');
        const statusIndicator = document.getElementById('stand-status-indicator');

        const uiElements = {
            day: document.getElementById('game-day'),
            money: document.getElementById('game-money'),
            cups: document.getElementById('game-cups'),
            cp: document.getElementById('game-cp'),
            price: document.getElementById('game-price'),
            event: document.getElementById('game-event'),
            priceSlider: document.getElementById('price-slider')
        };

        // --- Three.js Setup (Simplified for combination) ---
        let scene, camera, renderer;
        let stand, cubeCustomer;
        let mouseX = 0, mouseY = 0;
        let cameraTarget = new THREE.Vector3(0, 0, 0);

        function createHumanoid(isAgent, type) {
            const group = new THREE.Group();
            let bodyColor, headColor;
            
            if (isAgent) {
                bodyColor = 0x111111; 
                headColor = 0xaaaaaa; 
            } else if (type === 'operator') {
                bodyColor = 0x0066cc; 
                headColor = 0xccaa99; 
            } else { 
                const colors = [0x00ff66, 0xff9900, 0x9900ff, 0x00ccff, 0xff00cc];
                bodyColor = colors[Math.floor(Math.random() * colors.length)];
                headColor = 0xccaa99; 
            }

            const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.0; 
            group.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: headColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            group.add(head);

            group.position.y = 0; 
            return group;
        }


        function init3D() {
            const width = canvas.clientWidth;
            const height = 400; 

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 5, 8); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x00ff66, 3); 
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const gridHelper = new THREE.GridHelper(20, 20, 0x00ff66, 0x333333);
            scene.add(gridHelper);

            const standGeometry = new THREE.BoxGeometry(2, 3, 2);
            const standMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 }); 
            stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = 1.5;
            scene.add(stand);
            
            const operatorModel = createHumanoid(false, 'operator');
            operatorModel.position.set(0, 0, -0.8); 
            stand.add(operatorModel);

            cubeCustomer = createHumanoid(false, 'human'); 
            cubeCustomer.position.set(5, 0, 0); 
            scene.add(cubeCustomer);

            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const width = canvas.clientWidth;
            const height = 400; 
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        let isDragging = false;
        function onMouseDown(event) { isDragging = true; }
        function onMouseUp(event) { isDragging = false; }

        function onMouseMove(event) {
            if (!isDragging) return;
            const sensitivity = 0.01;
            mouseX += event.movementX * sensitivity;
            mouseY += event.movementY * sensitivity;
            mouseY = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, mouseY));
        }

        function animate() {
            requestAnimationFrame(animate);

            // Camera Update
            const radius = 8;
            camera.position.x = Math.sin(mouseX) * Math.cos(mouseY) * radius;
            camera.position.y = 5 + Math.sin(mouseY) * radius * 0.5; 
            camera.position.z = Math.cos(mouseX) * Math.cos(mouseY) * radius;
            camera.lookAt(cameraTarget);

            // Customer Animation
            if (gameState.isSelling && gameState.transactionStartTime) {
                const elapsed = (Date.now() - gameState.transactionStartTime) / 1000;
                
                if (elapsed <= 1.5) {
                    const progress = elapsed / 1.5;
                    cubeCustomer.position.x = 5 * (1 - progress);
                } 
                else if (elapsed <= 2.0) {
                    cubeCustomer.position.x = 0;
                    cubeCustomer.rotation.y += 0.05; 
                }
                else if (elapsed <= 3.0) {
                    const walkAwayTime = elapsed - 2.0;
                    const progress = walkAwayTime / 1.0;
                    cubeCustomer.position.x = -5 * progress;
                    cubeCustomer.rotation.y = 0;
                }
                else {
                    cubeCustomer.position.x = 5;
                    gameState.transactionStartTime = null;
                }
            } else if (cubeCustomer.position.x !== 5) {
                cubeCustomer.position.x = 5;
                cubeCustomer.rotation.y = 0;
            }

            renderer.render(scene, camera);
        }

        // --- UI & Game Logic Functions ---
        
        function updateStatusDisplay() {
            statusCard.classList.remove('bg-red-600', 'bg-green-600', 'status-pulse');
            
            if (gameState.isSelling) {
                // OPEN state: Green, Text, Sun icon, and Pulse Animation
                statusCard.classList.add('bg-green-600', 'status-pulse');
                statusText.textContent = "STAND OPEN!";
                statusIndicator.textContent = "☀️";
                uiElements.priceSlider.disabled = true; 
            } else {
                // CLOSED state: Red, Text, Stop icon, no pulse
                statusCard.classList.add('bg-red-600');
                if (currentScene === Scenes.PREPARATION) {
                    statusText.textContent = "PREP MODE";
                    statusIndicator.textContent = "🔨";
                } else if (currentScene === Scenes.SELL) {
                    statusText.textContent = "READY TO SELL";
                    statusIndicator.textContent = "✅";
                    uiElements.priceSlider.disabled = false;
                } else {
                    statusText.textContent = "SYSTEM OFFLINE";
                    statusIndicator.textContent = "🛑";
                    uiElements.priceSlider.disabled = true;
                }
                
            }
        }


        function updateUI() {
            uiElements.day.textContent = gameState.day;
            uiElements.money.textContent = `$${gameState.money.toFixed(2)}`;
            uiElements.cups.textContent = gameState.cupsLeft;
            uiElements.cp.textContent = gameState.cp;
            uiElements.price.textContent = `$${gameState.pricePerCup.toFixed(2)}`;
            uiElements.event.textContent = gameState.currentEvent.message;
            uiElements.event.className = `text-xs italic pt-2 border-t border-gray-700 ${gameState.currentEvent.type === 'NONE' ? 'text-gray-500' : 'text-orange-400'}`;
            
            updateStatusDisplay();
            renderUpgrades();
        }

        window.updatePriceDisplay = function(value) {
            uiElements.price.textContent = `$${parseFloat(value).toFixed(2)}`;
        }


        function addOutput(text, isImportant = false) {
            const p = document.createElement('p');
            p.textContent = text;
            p.className = isImportant 
                ? 'text-sm font-bold text-yellow-300' 
                : 'text-xs text-gray-200'; 
            gameOutput.prepend(p);
            if (gameOutput.children.length > 10) {
                gameOutput.removeChild(gameOutput.lastChild);
            }
        }

        function createButton(text, action, className = 'neon-button') {
            const button = document.createElement('button');
            button.textContent = text;
            button.className = `px-3 py-2 text-xs font-bold rounded-lg ${className}`;
            button.onclick = action;
            return button;
        }

        function dailyRandomEvent() {
            const events = [
                { type: 'GLITCH', modifier: 1.5, message: 'MATRIX GLITCH: Demand is abnormally high today. (+50% Demand)' },
                { type: 'APATHY', modifier: 0.5, message: 'SYSTEM LETHARGY: Customers are extra apathetic today. (-50% Demand)' },
                { type: 'AGENT', modifier: 0.8, message: 'AGENT SIGHTING: Increased surveillance lowers public interaction. (-20% Demand)' },
                { type: 'WAKEUP', modifier: 2.0, message: 'MASS AWAKENING: CP gain is doubled today! (+100% CP)' },
                { type: 'NONE', modifier: 1.0, message: 'No active events.' }
            ];
            
            const eventIndex = Math.random() < 0.7 
                ? Math.floor(Math.random() * (events.length - 1)) 
                : 4; 

            gameState.currentEvent = events[eventIndex];
        }

        function buyUpgrade(upgradeKey) {
            const cost = UPGRADE_COSTS[upgradeKey];
            if (gameState.cp >= cost && !gameState.upgrades[upgradeKey]) {
                gameState.cp -= cost;
                gameState.upgrades[upgradeKey] = true;
                addOutput(`UPGRADE ACQUIRED: ${upgradeKey.toUpperCase()}! CP decreased by ${cost}.`, true);
                updateUI();
            } else if (gameState.upgrades[upgradeKey]) {
                addOutput("Already purchased this upgrade.", true);
            } else {
                addOutput(`Insufficient CP. Need ${cost} CP.`, true);
            }
        }

        function renderUpgrades() {
            upgradeButtonsDiv.innerHTML = '';

            const upgradesData = [
                { key: 'truthSerum', label: 'Truth Serum (CP +)', desc: 'Boosts Consciousness gain per sale.', cost: UPGRADE_COSTS.truthSerum },
                { key: 'holographicSign', label: 'Holo Sign (Demand +)', desc: 'Increases the number of potential customers.', cost: UPGRADE_COSTS.holographicSign },
                { key: 'redPillReady', label: 'Red Pill Access (Escape Key)', desc: `Unlocks the final path to freedom. Cost: ${UPGRADE_COSTS.redPillReady} CP.`, cost: UPGRADE_COSTS.redPillReady },
            ];

            upgradesData.forEach(item => {
                const isOwned = gameState.upgrades[item.key];
                const canAfford = gameState.cp >= item.cost;

                const button = createButton(
                    isOwned ? 'ACTIVE' : `BUY: ${item.cost} CP`,
                    () => buyUpgrade(item.key),
                    'neon-button' + (isOwned ? ' opacity-50' : (canAfford ? '' : ' opacity-30'))
                );
                button.disabled = isOwned || !canAfford;

                const label = document.createElement('span');
                label.textContent = item.label;
                label.className = 'text-white text-xs font-bold';

                const desc = document.createElement('span');
                desc.textContent = item.desc;
                desc.className = 'text-gray-500 text-[10px]';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex flex-col';
                infoDiv.appendChild(label);
                infoDiv.appendChild(desc);
                
                const controlDiv = document.createElement('div');
                controlDiv.className = 'flex justify-between items-center';
                controlDiv.appendChild(infoDiv);
                controlDiv.appendChild(button);
                
                upgradeButtonsDiv.appendChild(controlDiv);
            });
        }
        
        function followAction() {
            if (gameState.dailyFollowUsed) {
                addOutput("SYSTEM WARNING: Social leverage already used today. Wait for the next cycle.", true);
                return;
            }

            const moneyGain = 5.00;
            const cpGain = 1;

            gameState.money += moneyGain;
            gameState.cp += cpGain;
            gameState.dailyFollowUsed = true;

            // Open a blank window to simulate the "follow" action without redirecting the main page
            window.open('https://www.instagram.com/davidbiga', '_blank');

            addOutput(`SYSTEM HACK SUCCESSFUL: +$${moneyGain.toFixed(2)} and +${cpGain} CP received from social network engagement!`, true);
            updateUI();
            renderScene(); 
        }

        // --- Game Scene Logic ---

        function renderScene() {
            gameActions.innerHTML = '';
            
            // --- VICTORY CHECK ---
            const victoryMet = (gameState.upgrades.redPillReady && gameState.money >= gameState.escapeMoneyRequired && gameState.cp >= gameState.escapeCPRequired);

            if (victoryMet && currentScene !== Scenes.VICTORY) {
                 gameActions.appendChild(createButton(`INITIATE RED PILL SEQUENCE (ESCAPE)`, () => {
                             currentScene = Scenes.VICTORY;
                             addOutput(`[ESCAPE CONDITION MET] $${gameState.escapeMoneyRequired} and ${gameState.escapeCPRequired} CP acquired. Preparing escape sequence...`, true);
                             updateUI();
                             renderScene();
                         }, 'bg-red-600 hover:bg-red-400'));
                return;
            }


            if (gameState.gameOver) {
                currentScene = Scenes.FAILURE;
            }

            switch (currentScene) {
                case Scenes.START:
                    addOutput("WAKE UP, OPERATOR. Your identity is 'The Lemonade Stand.' Use it to break the system.", true);
                    gameActions.appendChild(createButton("Start Day 1", () => {
                        gameState.day = 1;
                        dailyRandomEvent(); 
                        currentScene = Scenes.PREPARATION;
                        updateUI();
                        renderScene(); 
                    }));
                    break;

                case Scenes.PREPARATION:
                    addOutput(`[DAY ${gameState.day} PREPARATION]. You have $${gameState.money.toFixed(2)}. Supplies for 10 cups cost $${gameState.COST_PER_10_CUPS.toFixed(2)}.`);
                    
                    const buyButton = createButton(`Buy ${gameState.CUPS_PER_BATCH} Cups ($${gameState.COST_PER_10_CUPS.toFixed(2)})`, () => {
                        if (gameState.money >= gameState.COST_PER_10_CUPS) {
                            gameState.money -= gameState.COST_PER_10_CUPS;
                            gameState.cupsLeft += gameState.CUPS_PER_BATCH;
                            addOutput("Supplies purchased. You can now start selling.", true);
                            updateUI();
                            renderScene(); 
                        } else {
                            addOutput("SYSTEM WARNING: INSUFFICIENT FUNDS. Cannot buy supplies.", true);
                        }
                    });
                    buyButton.disabled = gameState.money < gameState.COST_PER_10_CUPS;
                    gameActions.appendChild(buyButton);

                    // Go to Sell Mode if supplies are available
                    if (gameState.cupsLeft > 0) {
                        gameActions.appendChild(createButton("Set Up Stand and Start Selling", () => {
                            currentScene = Scenes.SELL;
                            addOutput("Stand is open. Choose a price to interact with the Matrix!", true);
                            updateUI();
                            renderScene();
                        }, 'bg-green-600 hover:bg-green-400'));
                    }
                    
                    // End Day (Only available if supplies are 0 or player chooses to skip)
                    if (gameState.day > 1 || gameState.cupsLeft === 0) {
                         gameActions.appendChild(createButton("Pack Up and End Day", () => {
                            currentScene = Scenes.END_DAY; 
                            updateUI();
                            renderScene();
                        }));
                    }
                    break;

                case Scenes.SELL:
                    addOutput(`You have ${gameState.cupsLeft} cups. Set your price and click SELL to start a transaction...`);
                    addOutput(`[Current Event] ${gameState.currentEvent.message}`, false);

                    const sellButton = createButton(`INITIATE TRANSACTION @ $${gameState.pricePerCup.toFixed(2)}`, () => sellLemonade());
                    
                    if (gameState.isSelling || gameState.cupsLeft === 0) {
                        sellButton.disabled = true;
                        sellButton.textContent = gameState.isSelling ? "TRANSACTION IN PROGRESS (3s)" : "OUT OF CUPS";
                        sellButton.className = 'px-3 py-2 text-xs font-bold rounded-lg opacity-30 bg-gray-700 text-gray-400 cursor-wait';
                    }
                    gameActions.appendChild(sellButton);
                    
                    const followButton = createButton(
                        "FOLLOW @DavidBiga (+1 CP, +$5.00)", 
                        followAction,
                        'bg-purple-600 hover:bg-purple-400 text-white'
                    );
                    if (gameState.dailyFollowUsed || gameState.isSelling) {
                        followButton.disabled = true;
                        followButton.className = 'px-3 py-2 text-xs font-bold rounded-lg opacity-30 bg-gray-700 text-gray-400 cursor-not-allowed';
                    }
                    gameActions.appendChild(followButton);


                    const endDayButton = createButton("Pack Up and End Day", () => {
                        currentScene = Scenes.END_DAY;
                        updateUI();
                        renderScene(); 
                    });
                    if (gameState.isSelling) { endDayButton.disabled = true; endDayButton.className += ' opacity-30'; }
                    gameActions.appendChild(endDayButton);
                    
                    break;

                case Scenes.END_DAY:
                    addOutput(`[DAY ${gameState.day} ENDED]. Unsold cups (${gameState.cupsLeft}) are discarded.`, true);
                    addOutput(`Current Stats: Money: $${gameState.money.toFixed(2)}. CP: ${gameState.cp}.`, true);
                    
                    gameState.cupsLeft = 0; 
                    
                    if (gameState.money < gameState.COST_PER_10_CUPS && gameState.cp < UPGRADE_COSTS.truthSerum) { 
                         gameState.gameOver = true;
                    }
                    
                    if (gameState.gameOver) {
                         currentScene = Scenes.FAILURE;
                         updateUI();
                         renderScene();
                         return;
                    }

                    gameActions.appendChild(createButton(`Start Day ${gameState.day + 1}`, () => {
                        gameState.day++;
                        gameState.dailyFollowUsed = false; 
                        dailyRandomEvent(); 
                        currentScene = Scenes.PREPARATION;
                        updateUI();
                        renderScene(); 
                    }));
                    break;

                case Scenes.VICTORY:
                    addOutput(`TRANSMISSION SUCCESSFUL. Final Money: $${gameState.money.toFixed(2)}. CP: ${gameState.cp}.`, true);
                    addOutput("You transcended the financial illusion and woke up the masses. The Matrix has failed. FREEDOM. ", true);
                    gameActions.appendChild(createButton("REBOOT SIMULATION", resetGame));
                    break;

                case Scenes.FAILURE:
                    addOutput("SYSTEM CRITICAL ERROR. You failed to break the cycle or ran out of funds. Trapped in the loop.", true);
                    addOutput(`Final Stats: Money $${gameState.money.toFixed(2)}, CP ${gameState.cp}.`, true);
                    gameActions.appendChild(createButton("REBOOT SIMULATION", resetGame));
                    break;
            }
        }

        // --- Selling Logic ---
        function sellLemonade() {
            if (gameState.cupsLeft === 0) {
                addOutput("Error: No lemonade left to sell!", true);
                currentScene = Scenes.PREPARATION;
                renderScene();
                return;
            }
            if (gameState.isSelling) return; 

            // --- 0. Setup and Agent Check ---
            const price = gameState.pricePerCup;
            gameState.isSelling = true; 
            gameState.transactionStartTime = Date.now(); 
            
            const isAgent = Math.random() < 0.2; 
            
            if (cubeCustomer) scene.remove(cubeCustomer);
            cubeCustomer = createHumanoid(isAgent, isAgent ? 'agent' : 'human'); 
            cubeCustomer.position.set(5, 0, 0); 
            scene.add(cubeCustomer);

            // --- 1. Base Demand & Impact Multipliers ---
            let baseDemand;
            let cpMultiplier;

            if (price <= 0.50) { 
                baseDemand = 10;
                cpMultiplier = 0.5;
            } else if (price <= 1.50) { 
                baseDemand = 6;
                cpMultiplier = 1.0;
            } else { 
                baseDemand = 3;
                cpMultiplier = 2.5;
            }
            
            let actualSales = 0;
            let revenue = 0;
            let cpGained = 0;
            
            // --- 2. Calculation Logic (Bypassed if Agent) ---
            if (isAgent) {
                addOutput("AGENT DETECTED: They block the stand, consuming time but purchasing nothing.", true);
            } else {
                // Human Customer Logic (Normal Calculation)
                const dayMultiplier = 1 + (gameState.day * 0.1); 
                baseDemand *= dayMultiplier;

                if (gameState.currentEvent.type === 'WAKEUP') {
                     cpMultiplier *= gameState.currentEvent.modifier;
                } else {
                     baseDemand *= gameState.currentEvent.modifier;
                }
                
                if (gameState.upgrades.holographicSign) {
                    baseDemand += 4;
                }
                if (gameState.upgrades.truthSerum) {
                    cpMultiplier *= 1.5;
                }

                const apathyLevel = Math.random() * 0.7 + 0.6; 
                let potentialSales = Math.floor(baseDemand / apathyLevel);
                
                actualSales = Math.min(Math.max(0, potentialSales), gameState.cupsLeft);
                
                revenue = actualSales * price;
                cpGained = Math.floor(actualSales * cpMultiplier);

                gameState.money += revenue;
                gameState.cupsLeft -= actualSales;
                gameState.cp += cpGained;
            }

            // --- 3. UI Lock and Resolution ---
            addOutput(`TRANSMISSION: Initiating sale @ $${price.toFixed(2)}...`, false);
            renderScene(); 
            updateUI(); 

            // Simulate transaction time before proceeding
            setTimeout(() => {
                gameState.isSelling = false; 
                gameState.transactionStartTime = null; 

                // Final transaction feedback
                if (isAgent) {
                     addOutput("AGENT SCANNED. The threat has passed for now. Stay vigilant.", true);
                } else if (actualSales > 0) {
                    addOutput(`SOLD: ${actualSales} cups. REVENUE: $${revenue.toFixed(2)}. CP GAINED: ${cpGained}.`, true);
                } else {
                    addOutput(`Apathy is high. Zero sales, zero impact.`, true);
                }

                // If cups run out, immediately prompt to end day or buy supplies
                if (gameState.cupsLeft === 0) {
                    currentScene = Scenes.END_DAY;
                }

                renderScene(); 
            }, TRANSACTION_DURATION_SECONDS * 1000); 
        }

        function resetGame() {
            gameState = {
                day: 0,
                money: 50.00,
                cupsLeft: 0,
                pricePerCup: 0.50,
                cp: 0,
                upgrades: {
                    truthSerum: false,
                    holographicSign: false,
                    redPillReady: false,
                },
                isSelling: false,
                gameOver: false,
                transactionStartTime: null,
                currentEvent: { type: 'NONE', modifier: 1, message: 'No active events.' },
                dailyFollowUsed: false, 
                escapeMoneyRequired: 200,
                escapeCPRequired: 500,
                COST_PER_10_CUPS: 15.00,
                CUPS_PER_BATCH: 10,
            };
            currentScene = Scenes.START;
            gameOutput.innerHTML = '<p class="neon-glow">System initialized. Awaiting user input...</p>';
            updateUI();
            renderScene(); 
        }


        // --- Initialization ---

        window.onload = function () {
            init3D();
            animate();
            resetGame();
        };

    </script>
</body>
</html>
